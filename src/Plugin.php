<?php

/**
 * @file
 * Contains \FastFrame\Composer\Packages\Plugin
 */

namespace FastFrame\Composer\Packages;

use Composer\Composer;
use Composer\EventDispatcher\EventSubscriberInterface;
use Composer\Installer\InstallationManager;
use Composer\IO\IOInterface;
use Composer\Package\PackageInterface;
use Composer\Plugin\PluginInterface;
use Composer\Script\Event;
use Composer\Script\ScriptEvents;
use RuntimeException;
use Symfony\Component\Filesystem\Filesystem;

/**
 * Composer plugin that generates the Packages for use in the container
 *
 * @package FastFrame\Composer\Packages
 */
class Plugin
	implements PluginInterface, EventSubscriberInterface
{
	const COMPOSER_NAME = 'fastframe/composer-packages';

	/**
	 * @var string The output template
	 */
	private static $outputTemplate = <<<'EOF'
<?php

namespace FastFrame\Composer\Packages;

/**
 * This file is auto-generated by fastframe/composed on every run of `composer install` or `composer update`
 *
 * @date    $DATE
 * @package FastFrame\Composer\Packages
 */
interface $CLASS
{
	public const ROOT_PATH = $ROOT_PATH;
	public const PACKAGES = $PACKAGES;
	public const TYPES = $TYPES;
}
EOF;

	/**
	 * @var string The path to the root of the project
	 */
	protected $rootPath;

	/**
	 * {@inheritDoc}
	 */
	public function activate(Composer $composer, IOInterface $io)
	{
		// using event listeners
	}

	/**
	 * {@inheritDoc}
	 */
	public static function getSubscribedEvents(): array
	{
		return array(
			ScriptEvents::POST_INSTALL_CMD => 'dumpPackages',
			ScriptEvents::POST_UPDATE_CMD  => 'dumpPackages',
		);
	}

	public static function dumpPackages(Event $event)
	{
		$dumper = new self;
		$dumper->dump(
			$event->getComposer(),
			$event->getIO()
		);
	}

	/**
	 * Dumps the packages to the Packages.php file
	 */
	public function dump(Composer $composer, IOInterface $io)
	{
		$io->write("<info>Dumping package information</info>");
		$manager          = $composer->getInstallationManager();
		$root             = $composer->getPackage();
		$this->vendorPath = $composer->getConfig()->get('vendor-dir');
		$packages         = array();

		if ($root->getName() !== '__root__') {
			// resolves root package as absolute project root path
			$packages[$root->getName()] = $this->generatePackageInformation($root, $manager);
		}

		$repo = $composer->getRepositoryManager()->getLocalRepository();
		foreach ($repo->getPackages() as $package) {
			$name            = $package->getName();
			$packages[$name] = $this->generatePackageInformation($package, $manager);
		}

		$this->saveToFile($packages);
	}

	/**
	 * Saves the package to the Packages.php file
	 *
	 * @param array $packages
	 */
	protected function saveToFile(array $packages)
	{
		$ourPath = $packages[self::COMPOSER_NAME][3];
		$path    = "{$this->rootPath}{$ourPath}/src/Packages.php";
		$types   = array();
		foreach ($packages as $name => $pkg) {
			$types[$pkg[1]][] = $pkg[0];
		}

		file_put_contents(
			$path,
			strtr(
				self::$outputTemplate,
				array(
					'$CLASS'     => 'Packages',
					'$DATE'      => date('Y-m-d H:i:s'),
					'$PACKAGES'  => $this->renderForOutput($packages),
					'$ROOT_PATH' => $this->renderForOutput($this->rootPath),
					'$TYPES'     => $this->renderForOutput($types)
				)
			)
		);
		chmod($path, 0664);

		return;
	}

	/**
	 * Renders the data for use in the template
	 *
	 * @param mixed $data
	 * @return string
	 */
	protected function renderForOutput($data): string
	{
		return preg_replace(
			array(
				'/(\d+\s=>)/',
				'/\s+/',
				'/, \)/',
				'/array \( /'
			),
			array('', ' ', ')', 'array('),
			var_export($data, true)
		);
	}

	/**
	 * Cleans up the path
	 *
	 * @param $path
	 * @return bool|string
	 */
	protected function cleanPath($path)
	{
		// mindplay/composer-locator noticed an issue on windows installations, this cleans it up
		$path = strtr($path, '\\', '/');

		if (file_exists($file = "{$this->rootPath}/{$path}")) {
			// installer returns the relative path
			return $file;
		}

		return $path;
	}

	/**
	 * Generates the package information for the array
	 *
	 * @param PackageInterface    $pkg
	 * @param InstallationManager $manager
	 * @return array
	 */
	protected function generatePackageInformation(PackageInterface $pkg, InstallationManager $manager): array
	{
		// need to filter out composer information in the extra
		$extra = $pkg->getExtra();
		if (isset($extra['branch-alias'])) {
			unset($extra['branch-alias']);
		}

		return array(
			$pkg->getPrettyName(),
			$pkg->getType(),
			$pkg->getVersion(),
			$this->cleanPath($manager->getInstallPath($pkg)),
			$extra,
		);
	}
}
