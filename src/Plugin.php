<?php

/**
 * @file
 * Contains \FastFrame\Composer\Packages\Plugin
 */

namespace FastFrame\Composer\Packages;

use Composer\Composer;
use Composer\EventDispatcher\EventSubscriberInterface;
use Composer\Installer\InstallationManager;
use Composer\IO\IOInterface;
use Composer\Package\PackageInterface;
use Composer\Plugin\PluginInterface;
use Composer\Script\Event;
use Composer\Script\ScriptEvents;
use RuntimeException;
use Symfony\Component\Filesystem\Filesystem;

/**
 * Composer plugin that generates the Packages for use in the container
 *
 * @package FastFrame\Composer\Packages
 */
class Plugin
	implements PluginInterface, EventSubscriberInterface
{
	const NAME_KEY      = 0;
	const TYPE_KEY      = 1;
	const PATH_KEY      = 3;
	const COMPOSER_NAME = 'fastframe/composer-packages';

	/**
	 * @var string The output template
	 */
	private static $outputTemplate = <<<'EOF'
<?php

namespace FastFrame\Composer\Packages;

/**
 * This file is auto-generated by fastframe/composed on every run of `composer install` or `composer update`
 *
 * @date    $DATE
 * @package FastFrame\Composer\Packages
 */
interface $CLASS
{
	public const PACKAGES = $PACKAGES;
	public const TYPES = $TYPES;
}
EOF;

	/**
	 * @var string The path to the root of the project
	 */
	protected $rootPath;

	/**
	 * {@inheritDoc}
	 */
	public function activate(Composer $composer, IOInterface $io)
	{
		// using event listeners
	}

	/**
	 * {@inheritDoc}
	 */
	public static function getSubscribedEvents(): array
	{
		return array(
			ScriptEvents::POST_INSTALL_CMD => 'dumpPackages',
			ScriptEvents::POST_UPDATE_CMD  => 'dumpPackages',
		);
	}

	public static function dumpPackages(Event $event)
	{
		$dumper = new self;
		$dumper->dump(
			$event->getComposer(),
			$event->getIO()
		);
	}

	/**
	 * Dumps the packages to the Packages.php file
	 */
	public function dump(Composer $composer, IOInterface $io)
	{
		$io->write("<info>Dumping package information</info>");

		$manager        = $composer->getInstallationManager();
		$root           = $composer->getPackage();
		$repo           = $composer->getRepositoryManager()->getLocalRepository();
		$this->rootPath = $this->sterilizePath(\Composer\Factory::getComposerFile());
		if ($this->rootPath{0} === '.') {
			$this->rootPath = $this->sterilizePath(getcwd());
		}

		$packages = array();
		if ($root->getName() !== '__root__') {
			$packages[$root->getName()] = $this->generatePackageInformation($root, $manager);
		}

		foreach ($repo->getPackages() as $package) {
			$packages[$package->getName()] = $this->generatePackageInformation($package, $manager);
		}

		$this->saveToFile($packages);
	}

	/**
	 * Saves the package to the Packages.php file
	 *
	 * @param array $packages
	 */
	protected function saveToFile(array $packages)
	{
		$ourPath = $packages[self::COMPOSER_NAME][self::PATH_KEY];
		$types   = array();

		if (!is_writable($path = "{$this->rootPath}{$ourPath}/src/Packages.php")) {
			if (!is_writable($path = "{$ourPath}/src/Packages.php")) {
				throw new \RuntimeException("Unable to write Packages.php");
			}
		}

		foreach ($packages as $name => $pkg) {
			$types[$pkg[self::TYPE_KEY]][] = $pkg[self::NAME_KEY];
		}

		file_put_contents(
			$path,
			strtr(
				self::$outputTemplate,
				array(
					'$CLASS'     => 'Packages',
					'$DATE'      => date('Y-m-d H:i:s'),
					'$PACKAGES'  => $this->renderForOutput($packages),
					'$TYPES'     => $this->renderForOutput($types)
				)
			)
		);
		chmod($path, 0664);

		return;
	}

	/**
	 * Renders the data for use in the template
	 *
	 * @param mixed $data
	 * @return string
	 */
	protected function renderForOutput($data): string
	{
		return preg_replace(
			array(
				'/(\d+\s=>)/',
				'/\s+/',
				'/, \)/',
				'/array \( /'
			),
			array('', ' ', ')', 'array('),
			var_export($data, true)
		);
	}

	/**
	 * Cleans up the path
	 *
	 * mindplay/composer-locator noticed an issue on windows installations, this cleans it up
	 *
	 * @param $path
	 * @return bool|string
	 */
	protected function sterilizePath($path)
	{
		return str_replace('\\', '/', $path);
	}

	/**
	 * Normalizes the path by sterlizing and removing the rootPath
	 *
	 * @param $path
	 * @return bool|string
	 */
	protected function normalizePath($path)
	{
		return $this->sterilizePath(str_replace($this->rootPath, '', $path));
	}

	/**
	 * Generates the package information for the array
	 *
	 * @param PackageInterface    $pkg
	 * @param InstallationManager $manager
	 * @return array
	 */
	protected function generatePackageInformation(PackageInterface $pkg, InstallationManager $manager): array
	{
		// need to filter out composer information in the extra
		$extra = $pkg->getExtra();
		if (isset($extra['branch-alias'])) {
			unset($extra['branch-alias']);
		}

		return array(
			$pkg->getPrettyName(),
			$pkg->getType(),
			$pkg->getVersion(),
			$this->normalizePath($manager->getInstallPath($pkg)),
			$extra,
		);
	}
}
